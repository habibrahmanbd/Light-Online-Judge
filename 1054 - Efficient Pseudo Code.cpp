/*******************************
*   Bismiint64ah hir Rohmanir Rahim *
*   Habibur Rahman Habib        *
*   Dept. of CSE, RUET          *
*   habib_cse_ruet@yahoo.com  *
********************************/

using namespace std;

#include <bits/stdc++.h>
//type def
#define PI 2*acos (0.0)
typedef long long int64;
typedef unsigned long long int64u;
#define db double
#define pb push_back
#define pii pair<int ,int >
#define NL puts("")
#define MAX(p,q) p>q?p:q
#define MIN(p,q) p<q?p:q

//Intput_Output
#define input freopen ("input.txt", "r", stdin);
#define output freopen ("output.txt", "w", stdout);
#define pf printf
#define sf scanf
#define co cout
#define ci cin
#define II ({ int a; scanf("%d",&a); a;}) //Integer Input
#define IL ({ long a; scanf("%ld",&a);  a;})  //Long Integer Input
#define ILL ({ int64 a; scanf("%I64d",&a);  a;})  //Long Integer Input
#define ID ({ db a; scanf("%lf",&a);  a;}) //Double input
#define IC ({ char a; scanf("%c",&a);  a;}) //Character Input
#define IS ({ string a; cin >> a;  a;}) //String input
#define ICA(n) ({ char a[n]; scanf("%s",&a);  a;}) //Char-Array Input
#define OC(cs) printf("Case %d: ",cs);  //Case Input
//Loops.....
#define f(p, n, m) for(long int i=p; i<=n; i+=m)  //For Loop increment
#define fr(p, n, m) for(long int j=p; j>=n; j-=m)  //For loop decrement
//Problem wise define.....
#define MOD 1000000007
#define INF 1<<29
int64u _sieve_size;
bitset<65538> bs;   // 10^7 should be enough for most cases
#define vi vector<long long>
vi primes;
vi factors;
vi numberOfFactors;
int64u ans=1;
int64u x,y;
long long BigMod(long long b,long long p)
{
    if(p==1)
        return b;
    if(p%2==1)
        return(BigMod(b,p-1)*b)%MOD;
    else
    {
        long long res=BigMod(b,p/2);
        return (res*res)%MOD;
    }
}

void ExtendedEuclid(int64u a, int64u b)
{
    if(a%b==0)
    {
        x=0;
        y=1;
        return ;
    }
    ExtendedEuclid(b,a%b);
    int64u temp=x;
    x = y;
    y = temp - (a/b)*y;
}
//int64u pow(int64u a,int64u b, int64u m)
//{
//    int64u res = 1;
//    while(b)
//    {
//        if(b & 1)
//        {
//            res = ( (res % m) * (a % m) ) %m ;
//        }
//        a= ((a%m) * (a%m)) %m;
//        b >>= 1;
//    }
//    return res;
//}
//int64u modInverse(int64u a, int64u m)
//{
//    return pow(a,m-2,m);
//}
void sieve(int64u upperbound)            // create list of primes in [0..upperbound]
{
    _sieve_size = upperbound + 1;                   // add 1 to include upperbound
    bs.set();                                                 // set all bits to 1
    bs[0] = bs[1] = 0;                                     // except index 0 and 1
    for (int64u i = 2; i <= _sieve_size; i++) if (bs[i])
        {
            // cross out multiples of i starting from i * i!
            for (int64u j = i * i; j <= _sieve_size; j += i) bs[j] = 0;
            primes.push_back((int)i);  // also add this vector containing list of primes
        }
}

void primeFactors(int64u N)     // remember: vi is vector of integers, ll is long long
{
    //factors.clear();                    // vi `primes' (generated by sieve) is optional
    //numberOfFactors.clear();
    int64u PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
    while (N != 1 && (PF * PF <= N))     // stop at sqrt(N), but N can get smaller
    {
        int64u count=0;
        while (N % PF == 0)
        {
            N /= PF;    // remove this PF
            //factors.push_back(PF);
            count++;
        }
        if(count>0)
        {
            factors.push_back(PF);
            numberOfFactors.push_back(count);
            //co<<count<<endl;
            //co<<numberOfFactors[numberOfFactors.size()-1]<<endl;
        }
        PF = primes[++PF_idx];                              // only consider primes!
    }
    if (N != 1)
    {
        factors.push_back(N);    // special case if N is actually a prime
        numberOfFactors.push_back(1);
    }

    //return factors;         // if pf exceeds 32-bit integer, you have to change vi
}

void sumDiv(int64u m)
{
    for(long i=0; i<factors.size(); i++)
    {
        int64u ret1 =  BigMod(factors[i] ,(numberOfFactors[i]*m) + 1) - 1;
        ExtendedEuclid((factors[i]-1),MOD);
        int64u ret2 =  x;
        int64u ret=((ret1+MOD)%MOD * (ret2+MOD)%MOD )%MOD;
        ans=(ans%MOD * ret%MOD)%MOD ;
    }
}


int main()
{
    sieve(65537);
    //input;
    int t=II;
    int cs=1;
    while(t--)
    {
        int64u n,m;
        sf("%llu %llu",&n,&m);
        factors.clear();
        numberOfFactors.clear();
        primeFactors(n);
        ans=1;
        sumDiv(m);
        OC(cs++);
        pf("%llu\n",ans);
    }
    return 0;
}
